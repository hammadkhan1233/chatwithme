<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Real-Time Text Chat</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PeerJS is removed as VC is no longer required -->
    <style>
        /* Custom styles for better aesthetics */
        body { font-family: 'Inter', sans-serif; }
        #chat-window {
            height: 70vh; /* Increased height for chat since video is gone */
            max-height: 800px;
            overflow-y: auto;
            scroll-behavior: smooth;
        }
        .message-bubble-user {
            background-color: #2563eb; /* Blue-700 */
            align-self: flex-end;
            border-bottom-right-radius: 0;
        }
        .message-bubble-other {
            background-color: #374151; /* Gray-700 */
            align-self: flex-start;
            border-bottom-left-radius: 0;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen p-4 sm:p-8">

    <!-- Main App Content -->
    <div id="main-app-container">
        <div id="app" class="max-w-xl mx-auto space-y-8">
            <header class="text-center">
                <h1 class="text-4xl font-extrabold text-blue-400">Real-Time Text Chat</h1>
                <p id="user-status" class="text-sm mt-2 font-medium text-gray-400">
                    Connecting...
                </p>
            </header>

            <!-- Text Chat Section (Now centered and larger) -->
            <div class="bg-gray-800 p-4 rounded-xl shadow-lg flex flex-col">
                <h2 class="text-xl font-semibold mb-3 text-white">Public Chat Room</h2>
                
                <!-- Chat Window -->
                <div id="chat-window" class="flex-grow p-3 space-y-4 bg-gray-900 rounded-lg border border-gray-700 mb-4">
                    <p class="text-gray-500 text-center text-sm mt-10">Messages will appear here once connected.</p>
                </div>

                <!-- Message Input -->
                <div class="flex gap-2">
                    <input type="text" id="message-input" placeholder="Type a message..." class="flex-grow p-3 rounded-lg bg-gray-700 border border-gray-600 focus:ring-blue-500 focus:border-blue-500 text-sm">
                    <button onclick="sendMessage()" class="bg-blue-600 hover:bg-blue-700 text-white font-bold p-3 rounded-lg transition duration-200 shadow-md">
                        Send
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, onSnapshot, query, orderBy, serverTimestamp, setDoc, doc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- GLOBAL SETUP ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let app, db, auth, userId = null;
        let isAuthReady = false;
        let userProfile = null; // Store the current user's profile
        let profilesCache = {}; // Cache for all user profiles
        
        // Document elements
        const userStatusEl = document.getElementById('user-status');
        const chatWindowEl = document.getElementById('chat-window');
        const messageInputEl = document.getElementById('message-input');

        // Firestore paths
        const PUBLIC_CHAT_PATH = `artifacts/${appId}/public/data/chats`;
        const PUBLIC_PROFILES_PATH = `artifacts/${appId}/public/data/profiles`; // Path for profiles

        // --- FIREBASE INITIALIZATION & AUTH ---

        async function initializeFirebase() {
            try {
                if (Object.keys(firebaseConfig).length === 0) {
                    console.error("Firebase configuration is missing.");
                    return;
                }
                
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                await new Promise((resolve) => {
                    const unsubscribe = onAuthStateChanged(auth, async (user) => {
                        unsubscribe(); 
                        if (user) {
                            userId = user.uid;
                        } else {
                            if (initialAuthToken) {
                                await signInWithCustomToken(auth, initialAuthToken);
                                userId = auth.currentUser.uid;
                            } else {
                                const anonymousUser = await signInAnonymously(auth);
                                userId = anonymousUser.user.uid;
                            }
                        }
                        isAuthReady = true;
                        
                        // Load or create a default profile and immediately enter the app
                        await checkAndLoadProfile();
                        
                        resolve();
                    });
                });
            } catch (error) {
                console.error("Firebase/Auth initialization failed:", error);
                userStatusEl.textContent = "Initialization Failed. Check Console.";
            }
        }

        async function checkAndLoadProfile() {
            if (!db || !userId) return;

            const profileDocRef = doc(db, PUBLIC_PROFILES_PATH, userId);
            const profileSnap = await getDoc(profileDocRef);

            if (profileSnap.exists()) {
                // Profile exists, load it
                userProfile = profileSnap.data();
            } else {
                // Profile does not exist, create and save a default profile
                const defaultProfile = {
                    name: `Guest-${userId.substring(0, 8)}`,
                    age: 'N/A',
                    gender: 'N/A',
                    userId: userId,
                    lastUpdate: serverTimestamp(),
                };
                await setDoc(profileDocRef, defaultProfile);
                userProfile = defaultProfile;
            }
            
            // Immediately start the main app after profile is set (default or saved)
            enterMainApp();
        }
        
        function enterMainApp() {
            // Update status display using the loaded or default profile
            userStatusEl.innerHTML = `<span class="text-white">Logged in as:</span> <span class="text-blue-300 font-bold">${userProfile.name}</span>`;

            // Start main app features
            setupProfilesCacheListener();
            setupTextChatListener();
        }

        // --- GLOBAL PROFILES CACHE (For displaying other users' details) ---

        function setupProfilesCacheListener() {
            if (!db) return;

            const q = query(collection(db, PUBLIC_PROFILES_PATH));

            onSnapshot(q, (snapshot) => {
                snapshot.forEach((doc) => {
                    const profile = doc.data();
                    profilesCache[profile.userId] = profile;
                });
                console.log("Profiles cache updated.");
            }, (error) => {
                console.error("Error listening to profiles:", error);
            });
        }


        // --- TEXT CHAT FUNCTIONS ---

        function setupTextChatListener() {
            if (!db) return;

            // Query messages ordered by timestamp
            const q = query(collection(db, PUBLIC_CHAT_PATH), orderBy('timestamp', 'asc'));

            onSnapshot(q, (snapshot) => {
                // Remove the "no messages" placeholder if messages exist
                if (chatWindowEl.firstElementChild && chatWindowEl.firstElementChild.classList.contains('text-gray-500')) {
                    chatWindowEl.innerHTML = '';
                }

                // Append new messages
                let newMessagesHtml = '';
                snapshot.docChanges().forEach((change) => {
                    if (change.type === "added") {
                        const message = change.doc.data();
                        newMessagesHtml += createMessageHtml(message);
                    }
                });

                // Clear and re-render only if there are substantial changes (simple approach)
                // A better approach for huge chats would be to only append, but for simplicity we clear on the full snapshot load.
                if (snapshot.docChanges().length > 0) {
                     // Clear and re-render all for simplicity and consistency
                    chatWindowEl.innerHTML = ''; 
                    snapshot.forEach((doc) => {
                        displayMessage(doc.data());
                    });
                }
                
                // Scroll to the bottom of the chat window
                chatWindowEl.scrollTop = chatWindowEl.scrollHeight;
            }, (error) => {
                console.error("Error listening to chat messages:", error);
            });
        }

        window.sendMessage = async function() {
            const text = messageInputEl.value.trim();
            if (text === "" || !db || !userId) return;

            try {
                await addDoc(collection(db, PUBLIC_CHAT_PATH), {
                    userId: userId,
                    name: userProfile.name, // Use the userProfile name
                    text: text,
                    timestamp: serverTimestamp(),
                });
                messageInputEl.value = '';
            } catch (error) {
                console.error("Error sending message:", error);
            }
        }
        
        function createMessageHtml(message) {
            const isUser = message.userId === userId;
            const time = message.timestamp ? new Date(message.timestamp.seconds * 1000).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }) : '...';
            
            // Use cached profile info if available
            const profile = profilesCache[message.userId] || { name: message.userId, gender: '', age: '' };
            const displayName = profile.name;
            const displayGender = profile.gender;
            const displayAge = profile.age;
            const metadata = (displayGender && displayGender !== 'N/A') ? ` (${displayGender}, ${displayAge})` : '';

            return `
                <div class="flex ${isUser ? 'justify-end' : 'justify-start'}">
                    <div class="max-w-xs sm:max-w-md p-3 rounded-xl shadow-md text-sm break-words ${isUser ? 'message-bubble-user text-white' : 'message-bubble-other text-gray-200'}">
                        <div class="font-bold ${isUser ? 'text-blue-200' : 'text-yellow-300'} text-xs mb-1 break-all">${isUser ? 'You' : displayName}${metadata}</div>
                        <p class="text-base">${message.text}</p>
                        <span class="text-[10px] opacity-70 mt-1 block text-right">${time}</span>
                    </div>
                </div>
            `;
        }

        function displayMessage(message) {
             const messageDiv = document.createElement('div');
             messageDiv.innerHTML = createMessageHtml(message);
             // Append the content of the messageDiv (which is the actual message structure)
             chatWindowEl.appendChild(messageDiv.firstElementChild);
        }

        // --- START APPLICATION ---
        initializeFirebase();

        // Add event listener for Enter key in chat input
        messageInputEl.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

    </script>
</body>
</html>
